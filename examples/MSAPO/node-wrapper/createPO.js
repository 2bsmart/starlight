import { formatProof, createPO as createPOTransaction } from './utils/shield';
import { generateProof } from './utils/zok';

import { flattenDeep } from './utils/crypto/conversions';
import { Element, elementify } from './utils/crypto/format-inputs';
import { edwardsDecompress } from './utils/crypto/ecc/compress-decompress';
import { concatenateThenHash } from './utils/crypto/hashes/sha256/sha256';

// eslint-disable-next-line
export const createPO = async (
  zkpPrivateKeyBuyer,
  oldMSAzkpPublicKeyBuyer,
  oldMSAzkpPublicKeySupplier,
  oldMSAtierBounds,
  oldMSApricesByTier,
  oldMSAhashOfTieredPricing,
  oldMSAminVolume,
  oldMSAmaxVolume,
  oldMSAsku,
  oldMSAerc20ContractAddress,
  oldMSAaccumulatedVolumeOrdered,
  oldMSAcommitment,
  oldMSAsalt,
  oldMSAindex,
  oldMSAnullifier,
  oldMSASiblingPath,

  newMSAzkpPublicKeyOfBuyer,
  newMSAzkpPublicKeyOfSupplier,
  newMSAhashOfTieredPricing,
  newMSAminVolume,
  newMSAmaxVolume,
  newMSAsku,
  newMSAerc20ContractAddress,
  newMSAaccumulatedVolumeOrdered,
  newMSAcommitment,
  newMSAsalt,

  poVolume,
  poPrice,
  poSku,
  poErc20ContractAddress,
  poCommitment,
  poSalt,
) => {
  oldMSASiblingPath = elementify(oldMSASiblingPath);
  const root = oldMSASiblingPath[0]; // we need to grab the root at the same time we grab the siblingPath, or they could mismatch.

  const _publicInputHash = concatenateThenHash(
    root.hex(64),
    oldMSAnullifier.hex(64),
    newMSAcommitment.hex(64),
    poCommitment.hex(64),
  );

  // Convert everything to an element class. We'll then order elements later.
  const publicInputHash = new Element(_publicInputHash, 'hex');
  const zkpPrivateKeyOfBuyer = new Element(zkpPrivateKeyBuyer, 'hex');

  const oldMSAzkpPublicKeyOfBuyer = elementify(edwardsDecompress(oldMSAzkpPublicKeyBuyer.hex()));

  const oldMSAzkpPublicKeyOfSupplier = elementify(
    edwardsDecompress(oldMSAzkpPublicKeySupplier.hex()),
  );

  // Structure the inputs array in the exact order expected by the zokrates main() function:
  const allInputs = [
    publicInputHash.field(248, 1, true),
    zkpPrivateKeyOfBuyer.field(128, 2),
    root.field(128, 2),

    oldMSAzkpPublicKeyOfBuyer.map(el => el.field(254, 1)),
    oldMSAzkpPublicKeyOfSupplier.map(el => el.field(254, 1)),
    oldMSAtierBounds.map(el => el.field(128, 1)),
    oldMSApricesByTier.map(el => el.field(128, 1)),
    oldMSAhashOfTieredPricing.field(128, 2),
    oldMSAminVolume.field(128, 1),
    oldMSAmaxVolume.field(128, 1),
    oldMSAsku.field(128, 2),
    oldMSAerc20ContractAddress.field(128, 2),

    oldMSAaccumulatedVolumeOrdered.field(128, 1),

    oldMSAcommitment.field(128, 2),
    oldMSAsalt.field(128, 2),
    oldMSAindex.field(128, 1),
    oldMSAnullifier.field(128, 2),
    oldMSASiblingPath
      .slice(1) // remove the root, as we pass that in separately
      .map(el => el.field(216, 1, true)), // we truncate to 216 bits, because 2*216 fits within a single sha256 digest.

    newMSAzkpPublicKeyOfBuyer.map(el => el.field(254, 1)),
    newMSAzkpPublicKeyOfSupplier.map(el => el.field(254, 1)),
    newMSAhashOfTieredPricing.field(128, 2),
    newMSAminVolume.field(128, 1),
    newMSAmaxVolume.field(128, 1),
    newMSAsku.field(128, 2),
    newMSAerc20ContractAddress.field(128, 2),

    newMSAaccumulatedVolumeOrdered.field(128, 1),

    newMSAcommitment.field(128, 2),
    newMSAsalt.field(128, 2),

    newMSAzkpPublicKeyOfBuyer.map(el => el.field(254, 1)),
    newMSAzkpPublicKeyOfSupplier.map(el => el.field(254, 1)),
    poVolume.field(128, 1),
    poPrice.field(128, 1),
    poSku.field(128, 2),
    poErc20ContractAddress.field(128, 2),

    poCommitment.field(128, 2),
    poSalt.field(128, 2),
  ];

  console.log(`\nRequesting a proof be generated by zokrates...`);
  const { proof } = await generateProof('createPO', flattenDeep(allInputs));
  const proofArray = formatProof(proof);

  const publicInputs = [
    root.hex(64),
    oldMSAnullifier.hex(64),
    newMSAcommitment.hex(64),
    poCommitment.hex(64),
  ];

  const {
    transactionHash,
    newMSALeafIndex,
    newMSALeafValue,
    newPOLeafIndex,
    newPOLeafValue,
    newRoot,
  } = await createPOTransaction(proofArray, publicInputHash.field(248, 1, true), publicInputs);

  console.log('\nCREATE PO TRANSACTION COMPLETE');

  return {
    transactionHash,
    newMSALeafIndex,
    newMSALeafValue,
    newPOLeafIndex,
    newPOLeafValue,
    newRoot,
  };
};
