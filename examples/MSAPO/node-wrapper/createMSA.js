import { formatProof, createMSA as createMSATransaction } from './utils/shield';
import { generateProof } from './utils/zok';

import { flattenDeep } from './utils/crypto/conversions';
import { Element, elementify } from './utils/crypto/format-inputs';
import { edwardsDecompress } from './utils/crypto/ecc/compress-decompress';
import { concatenateThenHash } from './utils/crypto/hashes/sha256/sha256';

/**
compute-witness, generate proof and send a transaction to the shield contract.
*/

// eslint-disable-next-line
export const createMSA = async (
  zkpPublicKeyBuyer,
  zkpPublicKeySupplier,
  tierBounds,
  pricesByTier,
  hashOfTieredPricing,
  minVolume,
  maxVolume,
  sku,
  erc20ContractAddress,
  accumulatedVolumeOrdered,
  commitment,
  salt,
) => {
  const _publicInputHash = concatenateThenHash(commitment.hex());
  // Convert everything to an element class. We'll then order elements later.
  const publicInputHash = new Element(_publicInputHash, 'hex');

  const zkpPublicKeyOfBuyer = elementify(edwardsDecompress(zkpPublicKeyBuyer.hex()));
  const zkpPublicKeyOfSupplier = elementify(edwardsDecompress(zkpPublicKeySupplier.hex()));

  // Structure the inputs array in the exact order expected by the zokrates main() function:
  const allInputs = [
    publicInputHash.field(248, 1, true),

    zkpPublicKeyOfBuyer.map(el => el.field(254, 1)),
    zkpPublicKeyOfSupplier.map(el => el.field(254, 1)),
    tierBounds.map(el => el.field(128, 1)),
    pricesByTier.map(el => el.field(128, 1)),
    hashOfTieredPricing.field(128, 2),
    minVolume.field(128, 1),
    maxVolume.field(128, 1),
    sku.field(128, 2),
    erc20ContractAddress.field(128, 2),

    accumulatedVolumeOrdered.field(128, 1),

    commitment.field(128, 2),
    salt.field(128, 2),
  ];

  console.log(`\nRequesting a proof be generated by zokrates...`);
  const { proof } = await generateProof('createMSA', flattenDeep(allInputs));
  const proofArray = formatProof(proof);

  const publicInputs = [commitment.hex()];

  const { transactionHash, leafIndex, leafValue, newRoot } = await createMSATransaction(
    proofArray,
    publicInputHash.field(248, 1, true),
    publicInputs,
  );

  console.log('\nCREATE MSA TRANSACTION COMPLETE');

  return {
    transactionHash,
    leafIndex,
    leafValue,
    newRoot,
  };
};
