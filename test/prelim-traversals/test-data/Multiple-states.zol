// SPDX-License-Identifier: CC0

pragma solidity ^0.8.0;

contract MultipleStates {

  secret uint256 private a;
  secret uint256 private b;

  function incr(uint256 value) public {
    unknown a += value;
    unknown b += value; // ERRORFUL - if we put known/unknown/blank, it will error. ASK MIRANDA FOR HELP ABOUT BUG
  }

  function decr(uint256 value) public {
    a -= value;
    b -= value;
  }
}

PER STATE VARIABLE:
Pros:
Each category is readable in one go, so easier to update / manage.
Cons:
Duplicated sections, which need to be removed at the end (with possibly unintended consequences)
mapping: {
  importStatements,
  parameters,
  preStatements,
  postStatements,
}
PoKoSK: {
  importStatements,
  parameters,
  postStatements,
}
nullification: {
  importStatements,
  parameters,
  preStatements,
  postStatements,
}
oldCommitmentPreimage: {
  importStatements,
  parameters,
  preStatements,
  postStatements,
}
oldCommitmentExistence: {
  importStatements,
  parameters,
  postStatements,
}
newCommitment: {
  importStatements,
  parameters,
  preStatements,
  postStatements,
}
incrementation: {
  importStatements,
  statements,
}
decrementation: {
  importStatements,
  statements,
}

ALTERNATIVE:
PER STATE VARIABLE:
Pros:
No duplication
Cons:
Probably more if/else stuff.
Code for each category is now spread out across the page, making updates to a circuit fiddlier.
importStatements: {
  // unique statements of:
  mapping,
  PoKoSK,
  nullification,
  oldCommitmentPreimage,
  oldCommitmentExistence,
  newCommitment,
  incrementation,
  decrementation,
}
parameters: {
  // unique statements of:
  mapping,
  PoKoSK,
  nullification,
  oldCommitmentPreimage,
  oldCommitmentExistence,
  newCommitment,
}
preStatements: {
  // unique statements of:
  mapping,
  nullification,
  oldCommitmentPreimage,
  newCommitment,
}
statements: {
  // unique statements of:
  incrementation,
  decrementation,
}
postStatements: {
  // unique statements of:
  mapping,
  PoKoSK,
  nullification,
  oldCommitmentPreimage,
  oldCommitmentExistence,
  newCommitment,
}

PROBLEM:
At the moment,


Build boilerplate nodes for bpSection: 'parameters'

For each stateVar:
  push bp['parameters'] for that stateVar's indicator's bp


a's class:

this['parameters'] = [ { mapping? }, { pokosk? }, { nullification? }, { oldCommitmentPreimage? }, { oldCommitmentExistence? }, { newCommitment? } ]
// question marks mean the presense of the object will depend on the stateVar's indicators.

b's class:

etc.

So we end up with nodes for parameters:

parameters.a.mapping
...
parameters.a.newCommitment
parameters.b.mapping
...
parameters.b.newCommitment

then nodes for preStatements:

preStatements.a.mapping
...
preStatements.a.newCommitment
preStatements.b.mapping
...
preStatements.b.newCommitment

etc.

This doesn't align nicely with what we want (because the SOLIDITY shield contract actually dictates the order, because we want gas-efficiency, so we want chunks of code of type 'nullification', 'commitmentRoot', 'newCommitments', ultimately).


CIRCUIT:

function.importStatements.mapping.common
function.importStatements.mapping.variable.a[key1]
function.importStatements.mapping.variable.a[key2]
function.importStatements.mapping.variable.b

function.importStatements.PoKoSK.common << some might overlap with earlier fixed ones...
function.importStatements.PoKoSK.variable.a[key1]
function.importStatements.PoKoSK.variable.a[key2]
function.importStatements.PoKoSK.variable.b

function.importStatements.nullification.common
function.importStatements.nullification.variable.a[key1]
function.importStatements.nullification.variable.a[key2]
function.importStatements.nullification.variable.b

                               ...

function.parameters.mapping.common
function.parameters.mapping.variable.a[key1]
function.parameters.mapping.variable.a[key2]
function.parameters.mapping.variable.b

function.parameters.PoKoSK.common
function.parameters.PoKoSK.variable.a[key1]
function.parameters.PoKoSK.variable.a[key2]
function.parameters.PoKoSK.variable.b

function.parameters.nullification.common
function.parameters.nullification.variable.a[key1]
function.parameters.nullification.variable.a[key2]
function.parameters.nullification.variable.b

                      ...


SHIELD CONTRACT:

contract.importStatements.verification.common
contract.importStatements.newCommitments.common
contract.importStatements.custom

contract.baseContracts.newCommitments.common

contract.enums.verification.custom ??????

contract.structs....

contract.stateVariableDeclarations.verification.common
contract.stateVariableDeclarations.newNullifiers.common
contract.stateVariableDeclarations.commitmentRoot.common
contract.stateVariableDeclarations.newCommitments.common
contract.stateVariableDeclarations.keyManagement.common
contract.stateVariableDeclarations.custom NO <--- visitor inserts

contract.constructor.common

contract.registerPublicKeys

contract.verify


OR, just...

contract.importStatements

contract.baseContracts

contract.stateVariableDeclarations

contract.constructor

contract.registerPublicKeys

contract.verify


CONTRACT'S CUSTOM FUNCTIONS:

function.parameters.custom NO <--- visitor inserts
function.parameters.common.proof
function.parameters.newNullifiers
function.parameters.commitmentRoot
function.parameters.newCommitments

function.postStatements.inputs.common
function.postStatements.inputs.newNullifiers
function.postStatements.inputs.commitmentRoot
function.postStatements.inputs.newCommitments
function.postStatements.inputs.custom <-- depends on variables
function.postStatements.verify

OR, just...

function.parameters

function.postStatements.inputs
function.postStatements.verify
