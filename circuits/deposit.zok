from "utils/pack/u32/nonStrictUnpack256.zok" import main as field_to_u32_8
from "./common/hashes/mimc/altbn254/mimc2.zok" import main as mimc2
from "utils/pack/bool/nonStrictUnpack256.zok" import main as field_to_bool_256
from "utils/pack/u32/unpack256ToBits.zok" import main as u32_8_to_bool_256
from "./common/hashes/sha256/pad1024ThenHash.zok" import main as sha256of1024

def main(\
	public field tokenId,\
	private field msg,\
	private u32[8] tokenOwners_tokenId_newCommitment_owner_publicKey,\
	private u32[8] tokenOwners_tokenId_newCommitment_salt,\
	public field tokenOwners_tokenId_newCommitment_commitment\
) -> ():


        // We need to hard-code the mappingId's of mappings into the circuit:
        field tokenOwners_mappingId = 6


        field tokenOwners_tokenId = msg


        field tokenOwners_tokenId_stateVarId_field = mimc2([tokenOwners_mappingId, tokenId])


        u32[8] tokenOwners_tokenId_stateVarId = field_to_u32_8(tokenOwners_tokenId_stateVarId_field)


        // prepare secret state 'balances_msg_0' for commitment

        u32[8] tokenOwners_tokenId_newCommitment_value = field_to_u32_8(tokenOwners_tokenId)

        // balances_msg_0_newCommitment_commitment - preimage check

        u32[8] tokenOwners_tokenId_newCommitment_commitment_check = sha256of1024([\
          ...tokenOwners_tokenId_stateVarId,\
          ...tokenOwners_tokenId_newCommitment_value,\
          ...tokenOwners_tokenId_newCommitment_owner_publicKey,\
          ...tokenOwners_tokenId_newCommitment_salt\
        ])

        assert(\
          field_to_bool_256(tokenOwners_tokenId_newCommitment_commitment)[8..256] == u32_8_to_bool_256(tokenOwners_tokenId_newCommitment_commitment_check)[8..256]\
        )

        return
